<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/////////////////////merope
randomize();
finished = 0;
stemtotal = 0;
geni = 0;
numi = 0;


xmin = x-100;
xmax = x+100;
ymin = y-100;
ymax = y+100;

chode = 0;
chibi = -1;

ig = 0;
is = 0;
//initial stem---------------------------------------------------------------
//set variables and then determine all nodes
for(i = 0; i &lt; 31999; i++){
    for(i2 = 0; i2 &lt; 16; i2++){
        stem[i, i2] = -1;
    }
}

stemgens = 5;
lendecay = 0.6;
diralt = 30;
nodemax = 12;
reserve = 20;
overflow = 60;
boost = 10;
bts = 1;


stemindex = 0;
genindex = 0;

//generation
stem[0, 0] = 0;
//parent stem
stem[0, 1] = -1;
//parent node
stem[0, 2] = 0;
//length
stem[0, 3] = 500// + random(100);
//direction
stem[0, 4] = 90;
//div nodes
stem[0, 5] = 3//round(random(4));//round(random(4));//1 + round(random(nodemax - 1));
//cap nodes
stem[0, 6] = 2//1 + round(random(2));//round(random(nodemax - stem[0, 5]));

//overflow
stem[0, 14] = 0;//reserve;

//priority
stem[0, 15] = 1;

//types: 1 = stem cap, 2 = stem div, 3 = leaf cap, 4 = leaf div 
var type = 0;
{
    //for every node slot mark the parent stem index and generate a type, energy goal, and energy
    var leafcount = 0;
    for (i = 0; i &lt; stem[0, 5] + stem[0, 6]; i++){
        //type
        //1 = stem cap, 2 = stem div, 3 = leaf cap, 4 = leaf div
        //if node index is less than div total
        if i &lt; stem[0, 5]{//div
            //make a div
            type = 2;//for now only stems in div
        }else{//cap
            //if we don't have a cap leaf
            if leafcount &lt; 1{
                type = 3;//create one cap leaf
            }else{
            //otherwise put whatever we want on cap
                type = 1;//cap stem
            }

            if type == 3 || type == 4{leafcount++;}
        }
        //if it's going to be a stem, tell that stem its parent here
        var a = get_available_stem();
        {
            if a != -1{
                stem[a, 0] = 1;
                stem[a, 1] = 0;
                stem[a, 2] = i;
                stem[a, 13] = type;
                stemtotal++;
            }
        }
    }
    //stem[0, 7] = node;
}

//x
stem[0, 8] = x;
//y
stem[0, 9] = y;
//can we grow
stem[0, 10] = 1;
//goal - only the origin stem has energy and goal contained in its regular array, because it has no parent to refer to
stem[0, 11] = 100;
//energy
stem[0, 12] = 1;
//type
stem[0, 13] = 1;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///generate stems
//whole thing scales up as it grows                                                                   make it so each stem always has at least 2 leaves on cap and have those be the first thing to grow
//but individual branches grow once their parent branch reaches them
//plant starts with energy reserve from the seed                             red = stemindex
//cycle through every generation
if ig &lt; stemgens{
    //cycle through every stem in that generation
    if is &lt; get_gen_stem_total(ig){
        var parent = nth_stem_in_gen(ig, is);//index of every stem in the generation
        {
            //for every child of parent stem
            for(n = 0; n &lt; stem[parent, 5] + stem[parent, 6]; n++){
                //get the child stem index
                stemindex = get_existing_child_of_stem(parent, n);
                if stemindex != -1{
                    //get the node info from parent
                    //var node = stem[parent, 7];
                    //{
                        //do different stuff depending on type
                        //switch (stem[stemindex, 13]){//(node[stem[stemindex, 2], 1]){//(node[stem[stemindex, 2], 1])
                        //if it's a stem 
                        if stem[stemindex, 13] == 1 || stem[stemindex, 13] == 2{
                            //length
                            stem[stemindex, 3] = stem[parent, 3]*lendecay//*(1+(random(2)/10)*choose(1, -1));
                            //direction
                            stem[stemindex, 4] = stem[parent, 4]+(45)//*choose(1, -1))//((stem[i, 2] mod 2)*2 - 1));//stem[parent, 4]+(random(diralt)*choose(1, -1));
                            //div nodes
                            stem[stemindex, 5] = 3//+round(random(2));
                            //cap nodes
                            stem[stemindex, 6] = 2//+round(random(2));
                            //cangrow
                            stem[stemindex, 10] = 0;
                            
                            //position
                            //div
                            if stem[stemindex, 13] == 2{
                                //x (parentx + lengthdir_x(parentlength*(node/divnodes), parentdir))
                                stem[stemindex, 8] = stem[parent, 8] + lengthdir_x(stem[parent, 3]*(stem[stemindex, 2]+.5)/stem[parent, 5], stem[parent, 4]);
                                //y
                                stem[stemindex, 9] = stem[parent, 9] + lengthdir_y(stem[parent, 3]*(stem[stemindex, 2]+.5)/stem[parent, 5], stem[parent, 4]);
                            }
                            //cap
                            if stem[stemindex, 13] == 1{
                                //x (parentx + lengthdir_x(parentlength, parentdir))
                                stem[stemindex, 8] = stem[parent, 8] + lengthdir_x(stem[parent, 3]/*(stem[parent, 12]/stem[parent, 11])*/, stem[parent, 4]);
                                //y
                                stem[stemindex, 9] = stem[parent, 9] + lengthdir_y(stem[parent, 3]/*(stem[parent, 12]/stem[parent, 11])*/, stem[parent, 4]);
                            }
                            
                            //energy goal
                            stem[stemindex, 11] = 100;
                            //energy
                            stem[stemindex, 12] = 0;
                            //type
//333333333333333333333                            //stem[stemindex, 13] = 1; 
                            //overflow
                            stem[stemindex, 14] = 0;
                            //priority
                            stem[stemindex, 15] = 1;
                            
                            //now set up the nodes for each stem
                            var type = 0;
                            {
                                //for every node slot mark the parent stem index and generate a type, energy goal, and energy
                                var leafcount = 0;
                                for (ij = 0; ij &lt; stem[stemindex, 5] + stem[stemindex, 6]; ij++){
                                    //decide type
                                    //if local index is less than div items
                                    if ij &lt; stem[stemindex, 5]{
                                        //then make a div item
                                        type = 2;//only stems on div right now
                                    }else{//if local index is greater than div total
                                        //make cap items
                                        //make sure there's at least one cap leaf
                                        if leafcount &lt; 1{//every branch must have at least on leaft to justify its existence
                                            type = 3;
                                        }else{
                                            //if there's already a cap leaf then we can have option for stems or more leaves
                                            type = 1;//for now second cap node will only be stems
                                        }
                                        //if we're a leaf add to leaf count
                                        if type == 3 || type == 4{leafcount++;}
                                    }
                                    
                                    //set up basic info for the stem
                                    if !((type = 1 || type = 2) &amp;&amp; ig &gt;= stemgens - 2){//if we aren't going to be a stem on the final generation
                                        var aj = get_available_stem();
                                        {
                                            if aj != -1{
                                                //generation
                                                stem[aj, 0] = stem[stemindex, 0] + 1;
                                                //parent index
                                                stem[aj, 1] = stemindex;
                                                //local index
                                                stem[aj, 2] = ij;
                                                //type
                                                stem[aj, 13] = type;
                                                stemtotal++;
                                            }
                                        }
                                    }
                                    
                                }
                                //store the node array in slot 7 of this index in stem
                                //if node2 != -1{stem[stemindex, 7] = node2;}
                            }
                        }
                        
                        //if it's a leaf
                        if stem[stemindex, 13] == 3 || stem[stemindex, 13] == 4{
                            //width
                            stem[stemindex, 3] = 20;
                            //height
                            stem[stemindex, 4] = stem[stemindex, 3]/4;
                            
                            //if we're a div node
                            if stem[stemindex, 13] == 4{
                                //x (parentx + lengthdir_x(parentlength*(node/divnodes), parentdir))
                                stem[stemindex, 5] = stem[parent, 8] + lengthdir_x(stem[parent, 3]*(stem[stemindex, 2]+.5)/stem[parent, 5], stem[parent, 4]);
                                //y
                                stem[stemindex, 6] = stem[parent, 9] + lengthdir_y(stem[parent, 3]*(stem[stemindex, 2]+.5)/stem[parent, 5], stem[parent, 4]);
                                
                                //contribution score
                                stem[stemindex, 15] = 5;
                            }
                            
                            //if we're a cap node
                            if stem[stemindex, 13] == 3{
                                //x (parentx + lengthdir_x(parentlength, parentdir))
                                stem[stemindex, 5] = stem[parent, 8] + lengthdir_x(stem[parent, 3]/*(stem[parent, 12]/stem[parent, 11])*/, stem[parent, 4]);
                                //y
                                stem[stemindex, 6] = stem[parent, 9] + lengthdir_y(stem[parent, 3]/*(stem[parent, 12]/stem[parent, 11])*/, stem[parent, 4]);
                                
                                //contribution score
                                stem[stemindex, 15] = 10;//leaves on the cap get higher priority because they are the main provider for the stem
                            }
                            //direction
                            stem[stemindex, 7] = n*20;
                            //goal
                            stem[stemindex, 8] = 50;
                            //energy
                            stem[stemindex, 9] = 0;
                            //can grow
                            stem[stemindex, 10] = 0;
                            //overflow
                            //stem[stemindex, 14] = 0;
                            
                        }
                    //}
                }
            }
        }
        is++;
    }else{
        ig++;
        is = 0;
    }
}else{
    finished = 1;
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///grow

if finished == 1{
    //reserve += .25;
    for(i = 0; i &lt; array_height_2d(stem) &amp;&amp; stem[i, 0] != -1; i++){
    
        //if we're not playing a roll we lose growth priority
        stem[i, 15] -= .000001;
        
        stem[i, 15] = clamp(stem[i, 15], 0, 10);
    
        //for stems
        if stem[i, 13] == 1 || stem[i, 13] == 2{
            var go = 0, pn;
            //if the parent can grow
            //or if we're origin
            if stem[i, 0] = 0{go = 1;}
            else{
                if stem[stem[i, 1], 10] != 0{go = 1;}
            }
            
            if go == 1{
                //if we can't grow yet
                if stem[i, 10] == 0{       
                
                    var p = stem[i, 1], g;
                    {       
                        //if we're on the cap we can grow immediately
                        //if stem[i, 13] == 1{
                        //    stem[i, 10] = 1;
                        //}
                        //if stem[i, 13] == 2{//for divs
                            //get parent energy
                            g = stem[p, 12]/stem[p, 11];
                            //if distance between ourself and parent is less than parent length
                            if stem[p, 3] * g &gt; point_distance(stem[i, 8], stem[i, 9], stem[p, 8], stem[p, 9]){
                                //we can grow
                                stem[i, 10] = 1;
                            }
                        //}
                    }

                //otherwise if we can grow
                }else{
                    var lp = clamp(stem[i, 10] - 1, 0, 1)/10;//leaf proportional growth
                    {
                        //if we're not original stem
                        if stem[i, 0] &gt; 0{
                            //base transfer speed time priority times cap leaf progress
                            var enrgy = bts//*stem[i, 15];
                            {
    
                                //use some of our energy to wiggle around and if we hit sunlight stop
                                if stem[i, 14] &gt; bts/2*lp{
                                  stem[i, 4] += (random(10)/5*choose(1, -1))/(stem[i, 15])*(1 - stem[i, 12]/stem[i, 11])//*lp;
                                    stem[i, 14] -= bts/2*lp;
                                }
                                
                                ///giving parent our overflow
                                //if parent overflow is less than our overflow we need to give it ours
                                if stem[stem[i, 1], 14] &lt; stem[i, 14] + enrgy{///see if this growth should be scaled to leaf progress ---------
                                    stem[i, 14] -= enrgy;
                                    stem[stem[i, 1], 14] += enrgy;
                                }else{//if parent cant take the energy and we arent done growing then convert it into length
                                    //if stem[i, 10] &gt; 1{
                                        if stem[i, 12] + bts*lp &lt; stem[i, 11]{
                                            stem[i, 14] -= bts*lp;
                                            stem[i, 12] += bts*lp;
                                        }
                                    //}
                                }
                            }
                        }else{//origin stem gets energy from reserves
                            if reserve &gt; bts*lp{
                                if stem[i, 14] &lt; overflow{
                                    stem[i, 14] += bts;
                                    reserve -= bts;
                                }
                            }
                            
                            //if we still need to grow
                            if stem[i, 12] + bts*lp &lt; stem[i, 11]{
                                //if we have overflow to spare
                                if stem[i, 14] &gt; bts*lp{
                                    stem[i, 14] -= bts*lp;
                                    stem[i, 12] += bts*lp;
                                }
                            }
                        }                       
                        
                        
                        //reposition after length change
                        //if there's a parent
                        if stem[i, 1] != -1{
                            var parent = stem[i, 1], g;
                            {
                                g = stem[parent, 12]/stem[parent, 11];
                                
                                if stem[i, 13] == 2{//div nodes
                                    //x (parentx + lengthdir_x(parentlength*(node/divnodes), parentdir))
                                    stem[i, 8] = stem[parent, 8] + lengthdir_x(stem[parent, 3]*(stem[i, 2]+.1)/stem[parent, 5], stem[parent, 4]);
                                    //y
                                    stem[i, 9] = stem[parent, 9] + lengthdir_y(stem[parent, 3]*(stem[i, 2]+.1)/stem[parent, 5], stem[parent, 4]);
                                }
                                
                                if stem[i, 13] == 1{//cap nodes
                                    //x (parentx + lengthdir_x(parentlength, parentdir))
                                    stem[i, 8] = stem[parent, 8] + lengthdir_x(stem[parent, 3]*g, stem[parent, 4]);
                                    //y
                                    stem[i, 9] = stem[parent, 9] + lengthdir_y(stem[parent, 3]*g, stem[parent, 4]);
                                }
                                
                            }
                        }
                        
                        
                    }
                }
            }//go
                    
        }
        
        
        
        
        
        
        //for leaf
        if stem[i, 13] == 3 || stem[i, 13] == 4{
            var go = 0;
            //if the parent can grow
            //or if we're origin
            if stem[i, 0] = 0{go = 1;}
            else{if stem[stem[i, 1], 10] != 0{go = 1;}}

            if go == 1{
                //if we can't grow yet
                if stem[i, 10] == 0{
                    var p = stem[i, 1], g;
                    {   
                            //if we're on the cap we can grow immediately
                            if stem[i, 13] == 3{
                                stem[i, 10] = 1;
                            }
                            
                            if stem[i, 13] == 4{//for divs
                                //get parent energy
                                g = stem[p, 12]/stem[p, 11];
                                //if distance between ourself and parent is less than parent length
                                if stem[p, 3] * g &gt; point_distance(stem[i, 5], stem[i, 6], stem[p, 8], stem[p, 9]){
                                    //we can grow
                                    stem[i, 10] = 1;
                                }
                            }
                    }
                //otherwise if we can grow
                }else{
                    ///taking energy from parent
                    //if we need energy
                    if stem[i, 9] &lt; stem[i, 8]{
                    chode++
                        var enrgy = 1//bts*stem[i, 15];
                        {
                            //if parent has the energy to spare
                            if stem[stem[i, 1], 14] &gt;= enrgy{
                                //remove energy from the parent
                                stem[stem[i, 1], 14] -= enrgy;
                                //give it to us
                                stem[i, 9] += enrgy;
                            }
                            
                            //if we have a grandparent
                            if stem[i, 0] &gt; 1{
                                //if grandparent has the energy to spare
                                if stem[stem[stem[i, 1], 1], 14] &gt;= enrgy{
                                    //remove energy from the grandparent
                                    stem[stem[stem[i, 1], 1], 14] -= enrgy;
                                    //give it to us
                                    stem[i, 9] += enrgy;
                                }
                            }
                            
                        }
                    }
                    
                    //Photosynthesis
                    //are we the closest leaf
                    if o_sun.plant = self{
                        if o_sun.leaf = i{
                            //if we need the energy give it to self
                            if stem[i, 9] &lt; stem[i, 8]{//-
                                stem[i, 9] += bts;
                            }else{
                                var p = stem[i, 1];//, lp;
                                {
                                    //lp = clamp(stem[p, 10] - 1, 0, 1);
                                    //give parent energy in the form of overflow
                                    //if parent can take energy
                                    if stem[p, 14] &lt; overflow{///stem[p, 0]{
                                        //give them energy
                                        stem[p, 14] += bts;
                                        //give ourself and parent contribution points
                                        stem[i, 15] += .0005;
                                        stem[p, 15] += .0005;
                                    }
                                }
                            }
                        }
                    }
                                      
                    //reposition after length change
                    if stem[i, 1] != -1{
                        var parent = stem[i, 1], g;
                        {
                            //adjust size
                            stem[i, 3] = 15*stem[i, 9]/stem[i, 8];    
                            stem[i, 4] = stem[i, 3]/6;
                        
                            g = stem[parent, 12]/stem[parent, 11];
                            
                            //div nodes
                            if stem[i, 13] == 4{
                                //x (parentx + lengthdir_x(parentlength*(node/divnodes), parentdir))
                                stem[i, 5] = stem[parent, 8] + lengthdir_x(stem[parent, 3]*(stem[i, 2]+.5)/stem[parent, 5], stem[parent, 4]);
                                //y
                                stem[i, 6] = stem[parent, 9] + lengthdir_y(stem[parent, 3]*(stem[i, 2]+.5)/stem[parent, 5], stem[parent, 4]);
                            }
                            //cap nodes
                            if stem[i, 13] == 3{
                                //x (parentx + lengthdir_x(parentlength, parentdir))
                                stem[i, 5] = stem[parent, 8] + lengthdir_x(stem[parent, 3]*g, stem[parent, 4]);
                                //y
                                stem[i, 6] = stem[parent, 9] + lengthdir_y(stem[parent, 3]*g, stem[parent, 4]);
                                
                                //if growth%(0-1) is more than parent leaf progress(1-2) minus 1
                                //if stem[i, 10] == 1{
                                if clamp(stem[i, 9]/stem[i, 8], 0, 1) &gt; stem[stem[i, 1], 10] - 1{
                                    //add our progress to parent
                                    stem[stem[i, 1], 10] = 1 + clamp(stem[i, 9]/stem[i, 8], 0, 1); //------------------------------------
                                }
                                //}
                            }                   
                            
                        }
                    }
                    
                    
                    
                        
                }
            }//go
                    
        }
        
        
        
        
        
        
    }
}

//blimb = fuckle
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///loading
if finished == 0{
    var xx = view_wport[0]/2, yy = view_hport[0]/2, w = 128, h = 32;
    draw_rectangle(xx - w/2, yy - h/2, xx+(ig/stemgens)*w/2, yy+(is/get_gen_stem_total(ig))*h/2, 0);
    draw_set_color(c_teal);
    draw_rectangle(xx - w/2, yy - h/2, xx + w/2, yy + h/2, 1);
    draw_set_color(c_white);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(font0);
texture_set_interpolation(0);
draw_set_color(c_white);
draw_text(100,75, string(stemtotal));
draw_text(mouse_x+200,mouse_y+100, string(chode));

if finished == 1{
for(i = 0; i &lt; array_height_2d(stem) &amp;&amp; stem[i, 0] != -1; i++){
    //if stem
    if stem[i, 13] == 1 || stem[i, 13] == 2{
    
    //debug
//    if stem[i, 13] == 1{if stem[i, 10] &gt; 0{draw_set_color(c_blue);}else{draw_set_color(c_red);}}
//    if stem[i, 13] == 2{if stem[i, 10] &gt; 0{draw_set_color(c_yellow);}else{draw_set_color(c_orange);}}
//    draw_line_width(stem[i, 8], stem[i, 9], stem[i, 8] + lengthdir_x(stem[i, 3]*(1), stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3]*(1), stem[i, 4]), 1);
//    draw_text(stem[i, 8] + lengthdir_x(stem[i, 3]*(1), stem[i, 4]) + 20, stem[i, 9] + lengthdir_y(stem[i, 3]*(1), stem[i, 4]) - 20, string(clamp(stem[i, 10] - 1, 0, 1)));

        if stem[i, 10] &gt; 0{
        
        //draw_set_color(c_blue);
        //draw_circle(stem[i, 8], stem[i, 9], 5, 1);
        
            var w = 20, eng = stem[i, 11], en = stem[i, 12], a;
            a = en/eng;
            w = (stem[i, 3]+stem[i, 14]*20)/75;//+stem[stem[i, 1], 3]/1.2;
            w = clamp(w, 1, 10);
            draw_set_color(make_color_rgb(clamp(255-35*stem[i, 0]-200*(1-a), 1, 255),255,clamp(255-20*stem[i, 0]-250*(1-a), 1, 255)));
            if stem[i, 0] != -1{//in lengthdir len = baselength * (energy/goal)
                draw_line_width(stem[i, 8], stem[i, 9], stem[i, 8] + lengthdir_x(stem[i, 3]*(stem[i, 12]/stem[i, 11]), stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3]*(stem[i, 12]/stem[i, 11]), stem[i, 4]), w);
                
            }
        }
    }
    
    if stem[i, 13] == 3 || stem[i, 13] == 4{
   
        //debug 
//        if stem[i, 10] &gt; 0{draw_set_color(c_blue);}else{draw_set_color(c_red);}
//        draw_text(stem[i, 5]+100, stem[i, 6], string(stem[i,9])+"/"+string(stem[i,8]));
//        draw_line_width(stem[i, 5], stem[i, 6], stem[i, 5] + lengthdir_x(20, stem[stem[i, 1], 4]+stem[i, 7]*1), stem[i, 6] + lengthdir_y(20, stem[stem[i, 1], 4]+stem[i, 7]*1), 4*1);
        
        if stem[i, 10] &gt; 0{
            var energy, goal, g;
            {   
                energy = stem[i, 9];
                goal = stem[i, 8];
                //347
                g = energy/goal;
                
                draw_set_color(make_color_rgb(clamp(2/*55*/-35*stem[i, 0]-200*(1-g), 1, 255),255,clamp(255-20*stem[i, 0]-250*(1-g), 1, 255)));
                draw_line_width(stem[i, 5], stem[i, 6], stem[i, 5] + lengthdir_x(stem[i, 3]*g, stem[stem[i, 1], 4]+stem[i, 7]*g), stem[i, 6] + lengthdir_y(stem[i, 3]*g, stem[stem[i, 1], 4]+stem[i, 7]*g), 4*g);
                //draw_circle(stem[i, 5], stem[i, 6], 10*g, 0);
            }
        }
    }


}

draw_text(room_width/2, 100, string(chode));

var node = stem[0, 7];{
    for(i = 0; i &lt; array_height_2d(node); i++){
        draw_set_color(c_yellow);
        draw_text(5,200+10*i,string(node[i, 1]));
    }
}
}
//draw_set_color(c_red);
//draw_line(stem[0, 8], stem[0, 9], stem[0, 8] + lengthdir_x(stem[0, 3], stem[0, 4]), stem[0, 9] + lengthdir_y(stem[0, 3], stem[0, 4]));
//get_stem_index(gen, num)
//get_stem_parent_index(i)
//get_stem_child_index(i, childNum)
//var iii = get_stem_index(geni, numi), ib = get_existing_child_of_stem(geni, numi);
//draw_set_color(c_red);
//draw_line(stem[iii, 8], stem[iii, 9], stem[iii, 8] + lengthdir_x(stem[iii, 3], stem[iii, 4]), stem[iii, 9] + lengthdir_y(stem[iii, 3], stem[iii, 4]));
//draw_set_color(c_blue);
//draw_line(stem[ib, 8], stem[ib, 9], stem[ib, 8] + lengthdir_x(stem[ib, 3], stem[ib, 4]), stem[ib, 9] + lengthdir_y(stem[ib, 3], stem[ib, 4]));
//draw_text(100,150, string(ib));

/*
//generation
stem[0, 0] = 0;
//parent stem
stem[0, 1] = 0;
//parent node
stem[0, 2] = i;
//length
stem[0, 3] = 10 + random(100);
//direction
stem[0, 4] = random(180);
//div nodes
stem[0, 5] = round(random(12));
//cap nodes
stem[0, 6] = round(random(4));
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///debug
/*
for(i = 0; i &lt; array_height_2d(stem) &amp;&amp; stem[i, 0] != -1; i++){
    //draw_set_color(c_black);
    //if stem[i, 10] == 2{
    if stem[i, 10] == 1{
    if stem[i, 13] == 1 || stem[i, 13] == 2{
        //draw_set_color(c_black);
        //draw_rectangle(stem[i, 5], stem[i, 6], stem[i, 5] + 30, stem[i, 6] + 30, 0);
        //draw_set_color(c_red);
        //draw_line(stem[i, 5], stem[i, 6], stem[i, 5] + 10, stem[i, 6])
//        draw_text(stem[i, 5] + 25, stem[i, 6], string(stem[i, 9]));
        draw_set_color(c_white);
        draw_text(stem[i, 8] + lengthdir_x(stem[i, 3] + 25, stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3] + 25, stem[i, 4]), string(stem[i, 14]));
        draw_set_color(c_yellow);
        draw_text(stem[i, 8] + lengthdir_x(stem[i, 3] + 25, stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3] + 25, stem[i, 4]), string(stem[i, 10]));
    }

    if stem[i, 13] == 3 || stem[i, 13] == 4{
        //draw_set_color(c_black);
        //draw_rectangle(stem[i, 5], stem[i, 6], stem[i, 5] + 30, stem[i, 6] + 30, 0);
        //draw_set_color(c_red);
        //draw_line(stem[i, 5], stem[i, 6], stem[i, 5] + 10, stem[i, 6])
//        draw_text(stem[i, 5] + 25, stem[i, 6], string(stem[i, 9]));
        draw_set_color(c_teal);
        draw_text(stem[i, 5] + lengthdir_x(stem[i, 3] + 25, stem[stem[i, 1], 4] + stem[i, 4]), stem[i, 6] + lengthdir_y(stem[i, 3] + 25, stem[stem[i, 1], 4] + stem[i, 4]), string(stem[i, 14]));
        draw_set_color(c_orange);
        draw_text(stem[i, 5] + lengthdir_x(stem[i, 3] + 25, stem[stem[i, 1], 4] + stem[i, 4]), stem[i, 6] + lengthdir_y(stem[i, 3] + 25, stem[stem[i, 1], 4] + stem[i, 4]), string(stem[i, 10]));
    }
    }
}
/*
    draw_set_color(c_black);
    draw_rectangle(stem[i, 8] + lengthdir_x(stem[i, 3], stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), 30 + stem[i, 8] + lengthdir_x(stem[i, 3], stem[i, 4]), 30 + stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]),0);
    if stem[i, 8] != -1{
        draw_set_color(c_yellow);
        draw_text(stem[i, 8] + lengthdir_x(stem[i, 3], stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(stem[i, 2]));
        draw_set_color(c_red);
        draw_text(stem[i, 8] + lengthdir_x(stem[i, 3], stem[i, 4]), 10 + stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(stem[i, 10]));
        draw_set_color(c_lime);
        if stem[i, 0] != 0{
            var pnode = stem[stem[i, 1], 7];
            draw_text(stem[i, 8] + lengthdir_x(stem[i, 3], stem[i, 4]), 20 + stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(pnode[stem[i, 2], 3]));
        }
    }else{
        draw_set_color(c_yellow);
        draw_text(stem[i, 8] +25*i + lengthdir_x(stem[i, 3], stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(stem[i, 2]));
        draw_set_color(c_red);
        draw_text(stem[i, 8] +25*i + lengthdir_x(stem[i, 3], stem[i, 4]), 10 + stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(stem[i, 10]));
        draw_set_color(c_lime);
        draw_text(stem[i, 8] +25*i + lengthdir_x(stem[i, 3], stem[i, 4]), 20 + stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(stem[i, 8]));
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>331</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_restart_game</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*with instance_create(0, 0, o_plant){
    numi = other.numi;
}
stem = 0;
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
