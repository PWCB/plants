<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/////////////////////merope
randomize();
finished = 0;
stemtotal = 0;
geni = 0;
numi = 0;

chode = 0;
chibi = -1;

ig = 0;
is = 0;
//initial stem---------------------------------------------------------------
//set variables and then determine all nodes
for(i = 0; i &lt; 31999; i++){
    for(i2 = 0; i2 &lt; 12; i2++){
        stem[i, i2] = -1;
    }
}


stemgens = 8;
lendecay = 0.8;
diralt = 15;
nodemax = 12;

stemindex = 0;
genindex = 0;

//generation
stem[0, 0] = 0;
//parent stem
stem[0, 1] = -1;
//parent node
stem[0, 2] = 0;
//length
stem[0, 3] = 200// + random(100);
//direction
stem[0, 4] = 90;
//div nodes
stem[0, 5] = 0;//1 + round(random(nodemax - 1));
//cap nodes
stem[0, 6] = 2;//round(random(nodemax - stem[0, 5]));

//node[index, 0type(0none - 1stem - 2leaf - 3seed) - 1goal - 2energy]
var node;
{
    //for every node slot mark the parent stem index and generate a type, energy goal, and energy
    for (i = 0; i &lt; stem[0, 5] + stem[0, 6]; i++){
        //node[i, 1] = i mod 2
        //parent stem
        node[i, 0] = 0;
        //type
        //node[i, 1] = 1;
        if i &lt; stem[0, 5]{//if cap node or not
            node[i, 1] = 1//round(random(4));
        }else{
            node[i, 1] = 1//round(random(4));
        }
        //if it's going to be a stem, tell that stem its parent here
        if node[i, 1] = 1{
            var a = get_available_stem();
            {
                stem[a, 0] = 1;
                stem[a, 1] = 0;
                stem[a, 2] = i;
                stemtotal++;
            }
        }
        //energy goal
        node[i, 2] = 100;//random(250);
        //current energy
        node[i, 3] = 0;
    }
    stem[0, 7] = node;
}

//x
stem[0, 8] = x;
//y
stem[0, 9] = y;
//can we grow
stem[0, 10] = 1;
//goal - only the origin stem has energy and goal contained in its regular array, because it has no parent to refer to
stem[0, 11] = 100;
//energy
stem[0, 12] = 1;




/*
//cycle through every generation
for (ig = 0; ig &lt; stemgens; ig++){
    //cycle through every stem in that generation
    for (is = 0; is &lt; get_gen_stem_total(ig); is++){
        var parent = nth_stem_in_gen(ig, is);//index of every stem in the generation
        {
            //for every child of parent stem
            for(n = 0; n &lt; stem_child_total(parent); n++){
                //get the child stem index
                stemindex = get_existing_child_of_stem(parent, n)
                //get the node info from parent
                var node = stem[parent, 7];
                {
                    //if it's a stem 
                    if node[n, 1] = 1{
                        //stem[index, (0generation - 1parent stem index - 2parent node index - 3length - 4direction - 5node div - 6capnodes - 7node array, 8x, 9y)]
                        //generation
                        //stem[stemindex, 0] = 1;
                        //parent stem
                        //parent = 0;
                        //parent node
                        stem[stemindex, 2] = n;
                        //length
                        stem[stemindex, 3] = (.70+random(.60))*stem[parent, 3]*lendecay;
                        //direction
                        stem[stemindex, 4] = stem[parent, 4]+(9+random(diralt))*choose(1, -1);
                        //div nodes
                        stem[stemindex, 5] = 4;//1 + round(random(12));
                        //cap nodes
                        stem[stemindex, 6] = 6;//round(random(4));
                        
                        
                        if n &lt; stem[parent, 5]{//div nodes
                            //x (parentx + lengthdir_x(parentlength*(node/divnodes), parentdir))
                            stem[stemindex, 8] = stem[parent, 8] + lengthdir_x(stem[parent, 3]*(n+.5)/stem[parent, 5], stem[parent, 4]);
                            //y
                            stem[stemindex, 9] = stem[parent, 9] + lengthdir_y(stem[parent, 3]*(n+.5)/stem[parent, 5], stem[parent, 4]);
                        }else{//cap nodes
                            //x (parentx + lengthdir_x(parentlength, parentdir))
                            stem[stemindex, 8] = stem[parent, 8] + lengthdir_x(stem[parent, 3], stem[parent, 4]);
                            //y
                            stem[stemindex, 9] = stem[parent, 9] + lengthdir_y(stem[parent, 3], stem[parent, 4]);
                            
                            stem[stemindex, 4] = stem[parent, 4]+random(diralt)*choose(1, -1);
                        }
                        
                        //now set up the nodes for each stem-----------------------------------------------------------------
                        if stem[stemindex, 0] &lt; stemgens-2{
                        var node2;
                        {
                            //for every node slot mark the parent stem index and generate a type, energy goal, and energy
                            for (ij = 0; ij &lt; stem[stemindex, 5] + stem[stemindex, 6]; ij++){
                                //parent stem
                                node2[ij, 0] = stemindex;
                                //type
                                node2[ij, 1] = 1//round(random(3));
                                    //if it's going to be a stem, tell that stem its parent here
                                    if node[ij, 1] = 1{
                                        var aj = get_available_stem();
                                        {
                                            if aj = -1{break;}
                                            else{
                                                stem[aj, 0] = stem[stemindex, 0] + 1;
                                                stem[aj, 1] = stemindex;
                                            }
                                        }
                                    }
                                //energy goal
                                node2[ij, 2] = 100;//random(250);
                                //current energy
                                node2[ij, 3] = 0;
                            }
                            stem[stemindex, 7] = node;
                        }
                        }
                    }
                }
            }
        }
    }
}*/


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///generate stems
//whole thing scales up as it grows
//but individual branches grow once their parent branch reaches them
//plant starts with energy reserve from the seed                             red = stemindex
//cycle through every generation
if ig &lt; stemgens{
    //cycle through every stem in that generation
    if is &lt; get_gen_stem_total(ig){
        var parent = nth_stem_in_gen(ig, is);//index of every stem in the generation
        {
            //for every child of parent stem
            for(n = 0; n &lt; stem[parent, 5] + stem[parent, 6]/*stem_child_total(parent)*/; n++){
                //get the child stem index
                stemindex = get_existing_child_of_stem(parent, n);
                if stemindex != -1{
                //get the node info from parent
                var node = stem[parent, 7];
                {
                    //if it's a stem 
                    if node[stem[stemindex, 2], 1] = 1{chode++;
                        //stem[index, (0generation - 1parent stem index - 2parent node index - 3length - 4direction - 5node div - 6capnodes - 7node array, 8x, 9y)]
                        //generation
                        //stem[stemindex, 0] = 1;
                        //parent stem
                        //parent = 0;
                        //parent node
                        //stem[stemindex, 2] = n;
                        //length
                        stem[stemindex, 3] = stem[parent, 3]/1.2;
                        //direction
                        stem[stemindex, 4] = stem[parent, 3]-90+45*n;//10*stem[stemindex, 0]+stem[parent, 4]+(9+random(diralt))*choose(1, -1);
                        //div nodes
                        stem[stemindex, 5] = 0;//1 + round(random(12));
                        //cap nodes
                        stem[stemindex, 6] = 2;//round(random(4));
                        
                        stem[stemindex, 10] = 0;//stemindex;
                        
                        if stem[stemindex, 2] &lt; stem[parent, 5]{//div nodes
                            //x (parentx + lengthdir_x(parentlength*(node/divnodes), parentdir))
                            stem[stemindex, 8] = stem[parent, 8] + lengthdir_x(stem[parent, 3]*(n+.5)/stem[parent, 5], stem[parent, 4]);
                            //y
                            stem[stemindex, 9] = stem[parent, 9] + lengthdir_y(stem[parent, 3]*(n+.5)/stem[parent, 5], stem[parent, 4]);
                        }else{//cap nodes
                            //x (parentx + lengthdir_x(parentlength, parentdir))
                            stem[stemindex, 8] = stem[parent, 8] + lengthdir_x(stem[parent, 3], stem[parent, 4]);
                            //y
                            stem[stemindex, 9] = stem[parent, 9] + lengthdir_y(stem[parent, 3], stem[parent, 4]);
                            
                            //stem[stemindex, 4] = stem[parent, 4]+random(diralt)*choose(1, -1);
                        }
                        
                        //now set up the nodes for each stem-----------------------------------------------------------------
                        if ig &lt; stemgens{///changed this (stemgens - 1)
                        var node2;
                        {
                            //for every node slot mark the parent stem index and generate a type, energy goal, and energy
                            for (ij = 0; ij &lt; stem[stemindex, 5] + stem[stemindex, 6]; ij++){
                                //if ij &gt; stem[stemindex, 5]{cap = 1;}
                                //parent stem
                                node2[ij, 0] = stemindex;
                                //type
                                if ij &lt; stem[stemindex, 5]{//if cap node or not
                                    node2[ij, 1] = round(random(4));
                                }else{
                                    node2[ij, 1] = 1//round(random(4));
                                }
                                    //if it's going to be a stem, tell that stem its parent here
                                    if node2[ij, 1] = 1{
                                        var aj = get_available_stem();
                                        {
                                            if aj = -1{break;}
                                            else{
                                                stem[aj, 0] = stem[stemindex, 0] + 1;
                                                stem[aj, 1] = stemindex;
                                                stem[aj, 2] = ij;
                                                stemtotal++;
                                            }
                                        }
                                    }
                                //energy goal
                                node2[ij, 2] = 100;//random(250);
                                //current energy
                                node2[ij, 3] = 0;
                            }
                            stem[stemindex, 7] = node2;
                        }
                        }
                    }
                }
                }
            }
        }
        is++;
    }else{
        ig++;
        is = 0;
    }
}else{
    finished = 1;
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///grow
if finished == 1{
    for(i = 0; i &lt; array_height_2d(stem) &amp;&amp; stem[i, 0] != -1; i++){
    var go = 0;
    //if the parent can grow
    //or if we're origin
    if stem[i, 0] = 0{go = 1;}
    else{if stem[stem[i, 1], 10] == 1{go = 1;}}
    go = 1;
    if go == 1{
        if stem[i, 10] = 0{
            //parent index, grandparent index, parent node index, grandparent node array, parent energy, parent goal
            var p = stem[i, 1], pp, ni, ppnode, penergy, pgoal;
            {   
                //if the parent isn't origin stem
                if stem[p, 0] != 0{
                    //get parent of parent
                    pp = stem[p, 1];
                    //get grandparent node
                    ppnode = stem[pp, 7];
                    //index for parent node from grandparent node
                    ni = stem[p, 2];
                    //using the node index in the grandparent node array get the energy and goal
                    penergy = ppnode[ni, 3];
                    pgoal = ppnode[ni, 2];
                    //if the parent reaches us then we can start growing
                    if point_distance(stem[i, 8], stem[i, 9], stem[p, 8], stem[p, 9]) &lt;= 1.1* stem[p, 3] * penergy/pgoal{
                        stem[i, 10] = 1;
                    }
                }else{//if the parent is origin
                    //index for parent node from grandparent node
                    ni = stem[p, 2];
                    //using the node index in the grandparent node array get the energy and goal
                    penergy = stem[p, 12];
                    pgoal = stem[p, 11];
                    //if the parent reaches us then we can start growing
                    if point_distance(stem[i, 8], stem[i, 9], stem[p, 8], stem[p, 9]) &lt;= 1.1* stem[p, 3] * penergy/pgoal{
                        stem[i, 10] = 1;
                    }
                }
            }
        }else{
            //if we're not origin stem
            if stem[i, 0] != 0{
            //parent index, node index, parent node array
            var p = stem[i, 1], ni = stem[i, 2], pnode;
            {   
                pnode = stem[p, 7];
                ni = stem[i, 2];
                if pnode[ni, 3] &lt; pnode[ni, 2]{
                    pnode[ni, 3]++;
                }
            }
            }else{//if we are origin stem
                if stem[i, 12] &lt; stem[i, 11]{
                    stem[i, 12]++;
                }
            }
        }
        }
    }
}


/*
///grow
if finished == 1{
    for(i = 0; i &lt; array_height_2d(stem) &amp;&amp; stem[i, 0] != -1; i++){
        //if parent isn't origin
        if stem[stem[i, 1], 0] != 0{//-
            //if the parent can grow
            if stem[stem[i, 1], 10] == 1{
                //if we can't grow
                if stem[i, 10] = 0{
                    //parent index, grandparent index, parent node index, grandparent node array, parent energy, parent goal
                    var p = stem[i, 1], pp, ni, ppnode, penergy, pgoal;
                    {   
                        //get parent of parent
                        pp = stem[p, 1];
                        //get grandparent node
                        ppnode = stem[pp, 7];
                        //index for parent node from grandparent node
                        ni = stem[p, 2];
                        //using the node index in the grandparent node array get the energy and goal
                        penergy = ppnode[ni, 3];
                        pgoal = ppnode[ni, 2];
                        //if the parent reaches us then we can start growing
                        if point_distance(stem[i, 8], stem[i, 9], stem[p, 8], stem[p, 9]) &lt;= stem[p, 3] * penergy/pgoal{
                            stem[i, 10] = 1;
                        }
                    }
                }else{
                    //parent index, node index, parent node array
                    var p = stem[i, 1], ni = stem[i, 2], pnode;
                    {   
                        pnode = stem[p, 7];
                        ni = stem[i, 2];
                        if pnode[ni, 3] &lt; pnode[ni, 2]{
                            pnode[ni, 3]++;
                        }
                    }
                }
            }
        }else{        
            //if the parent is origin    
            //if the parent can grow
            //if stem[stem[i, 1], 10] == 1{
                //if we can grow
                if stem[i, 10] = 0{
                    //parent index, grandparent index, parent node index, grandparent node array, parent energy, parent goal
                    var p = stem[i, 1], pp, ni, ppnode, penergy, pgoal;
                    {   
                        //index for parent node from grandparent node
                        ni = stem[p, 2];
                        //using the node index in the grandparent node array get the energy and goal
                        penergy = stem[p, 12];
                        pgoal = stem[p, 11];
                        //if the parent reaches us then we can start growing
                        if point_distance(stem[i, 8], stem[i, 9], stem[p, 8], stem[p, 9]) &lt;= stem[p, 3] * penergy/pgoal{
                            stem[i, 10] = 1;
                        }
                    }
                }else{
                    if stem[i, 12] &lt; stem[i, 11]{
                        stem[i, 12]++;
                    }
                }
            //}
        }//-
    }
}
/*
take current stem
find parent
get node array from parent
does parent reach us (stem10) - take distance from parent to us, is it &lt;= parent length * parent node[energy]/parent node[energygoal]
if so add energy in our node[energy]


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if keyboard_check_pressed(vk_right){numi++;}
if keyboard_check_pressed(vk_left){numi--;}
if keyboard_check_pressed(vk_up){geni++;}
if keyboard_check_pressed(vk_down){geni--;}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
///debug
for(i = 0; i &lt; array_height_2d(stem) &amp;&amp; stem[i, 0] != -1; i++){
    draw_set_color(c_black);
    draw_rectangle(stem[i, 8] + lengthdir_x(stem[i, 3], stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), 30 + stem[i, 8] + lengthdir_x(stem[i, 3], stem[i, 4]), 30 + stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]),0);
    if stem[i, 8] != -1{
        draw_set_color(c_yellow);
        draw_text(stem[i, 8] + lengthdir_x(stem[i, 3], stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(stem[i, 2]));
        draw_set_color(c_red);
        draw_text(stem[i, 8] + lengthdir_x(stem[i, 3], stem[i, 4]), 10 + stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(stem[i, 10]));
        draw_set_color(c_lime);
        if stem[i, 0] != 0{
            var pnode = stem[stem[i, 1], 7];
            draw_text(stem[i, 8] + lengthdir_x(stem[i, 3], stem[i, 4]), 20 + stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(pnode[stem[i, 2], 3]));
        }
    }else{
        draw_set_color(c_yellow);
        draw_text(stem[i, 8] +25*i + lengthdir_x(stem[i, 3], stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(stem[i, 2]));
        draw_set_color(c_red);
        draw_text(stem[i, 8] +25*i + lengthdir_x(stem[i, 3], stem[i, 4]), 10 + stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(stem[i, 10]));
        draw_set_color(c_lime);
        draw_text(stem[i, 8] +25*i + lengthdir_x(stem[i, 3], stem[i, 4]), 20 + stem[i, 9] + lengthdir_y(stem[i, 3], stem[i, 4]), string(stem[i, 8]));
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(font0);
texture_set_interpolation(0);
draw_set_color(c_white);
draw_text(100,75, string(stemtotal));
draw_text(100,100, string(chode));


for(i = 0; i &lt; array_height_2d(stem) &amp;&amp; stem[i, 0] != -1; i++){
    //if stem
    if stem[i, 10] == 1{
        var w = 20;
        w /= 4*stem[i, 0] + 1;
        w = clamp(w, 1, 10);
        draw_set_color(make_color_rgb(255-25*stem[i, 0],255,255-20*stem[i, 0]));
        
        if stem[i, 0] != 0{
            var p = stem[i, 1], ni = stem[i, 2], pnode, energy, goal, g;
            {   
                pnode = stem[p, 7];
                ni = stem[i, 2];
                energy = pnode[ni, 3];
                goal = pnode[ni, 2];
            
                g = energy/goal;
                
                draw_line_width(stem[i, 8], stem[i, 9], stem[i, 8] + lengthdir_x(stem[i, 3]*g, stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3]*g, stem[i, 4]), w);
            }
        }else{
            var energy, goal, g;
            {   
                energy = stem[i, 12];
                goal = stem[i, 11];
            
                g = energy/goal;
                
                draw_line_width(stem[i, 8], stem[i, 9], stem[i, 8] + lengthdir_x(stem[i, 3]*g, stem[i, 4]), stem[i, 9] + lengthdir_y(stem[i, 3]*g, stem[i, 4]), w);
            }
        }
    }

}
var node = stem[0, 7];{
    for(i = 0; i &lt; array_height_2d(node); i++){
        draw_set_color(c_yellow);
        draw_text(5,200+10*i,string(node[i, 1]));
    }
}

draw_set_color(c_red);
//draw_line(stem[0, 8], stem[0, 9], stem[0, 8] + lengthdir_x(stem[0, 3], stem[0, 4]), stem[0, 9] + lengthdir_y(stem[0, 3], stem[0, 4]));
//get_stem_index(gen, num)
//get_stem_parent_index(i)
//get_stem_child_index(i, childNum)
//var iii = get_stem_index(geni, numi), ib = get_existing_child_of_stem(geni, numi);
//draw_set_color(c_red);
//draw_line(stem[iii, 8], stem[iii, 9], stem[iii, 8] + lengthdir_x(stem[iii, 3], stem[iii, 4]), stem[iii, 9] + lengthdir_y(stem[iii, 3], stem[iii, 4]));
//draw_set_color(c_blue);
//draw_line(stem[ib, 8], stem[ib, 9], stem[ib, 8] + lengthdir_x(stem[ib, 3], stem[ib, 4]), stem[ib, 9] + lengthdir_y(stem[ib, 3], stem[ib, 4]));
//draw_text(100,150, string(ib));

/*
//generation
stem[0, 0] = 0;
//parent stem
stem[0, 1] = 0;
//parent node
stem[0, 2] = i;
//length
stem[0, 3] = 10 + random(100);
//direction
stem[0, 4] = random(180);
//div nodes
stem[0, 5] = round(random(12));
//cap nodes
stem[0, 6] = round(random(4));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="13">
      <action>
        <libid>1</libid>
        <id>331</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_restart_game</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*with instance_create(0, 0, o_plant){
    numi = other.numi;
}
stem = 0;
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
